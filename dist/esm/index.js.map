{"version":3,"file":"index.js","sources":["../../src/date/FuDate.ts","../../src/array/asyncMap.ts","../../node_modules/tslib/tslib.es6.js","../../src/array/groupBy.ts","../../src/array/groupAndSort.ts","../../src/array/multiFilter.ts"],"sourcesContent":["import { IDateProperties, IFuDate } from \"./IFuDate\"\n\nclass FuDate implements IFuDate {\n  private readonly date: Date\n\n  /**\n   * Initializes the class with a given date value or the current date if no value is provided.\n   *\n   * @param {number | string | Date} [dateValue] - The value used to initialize the date. It can be a timestamp (number), a date string, a Date object, or undefined.\n   * - If no value is provided, the current date and time will be used.\n   * - If a valid value is provided, it will be parsed into a Date object.\n   * @throws {Error} Throws an error if the provided date value cannot be parsed into a valid Date object.\n   */\n  constructor(dateValue?: number | string | Date) {\n    if (typeof dateValue === \"undefined\") {\n      this.date = new Date()\n      return\n    }\n    this.date = this.parse(dateValue)\n  }\n\n  /**\n   * Retrieves the current date.\n   *\n   * @returns {Date} A Date object representing the current date and time.\n   */\n  getDate(): Date {\n    return this.date\n  }\n\n  /**\n   * Extracts various date and time properties from the Date object.\n   *\n   * @param {string} [locale] - Optional locale string for formatting the day of the week name. Defaults to the system's locale.\n   * @returns {IDateProperties} An object containing various date and time properties such as year, month, day, day of the week, and formatted strings.\n   */\n  getDateProperties(locale?: string): IDateProperties {\n    const localeValue = locale\n      ? locale\n      : Intl.DateTimeFormat().resolvedOptions().locale\n    const year = this.date.getFullYear().toString()\n    const month = (this.date.getMonth() + 1).toString().padStart(2, \"0\")\n    const day = this.date.getDate().toString().padStart(2, \"0\")\n    const hour = this.date.getHours().toString().padStart(2, \"0\")\n    const minute = this.date.getMinutes().toString().padStart(2, \"0\")\n    const second = this.date.getSeconds().toString().padStart(2, \"0\")\n\n    return {\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second,\n      yearMonthDay: `${year}-${month}-${day}`,\n      yearMonth: `${year}-${month}`,\n      monthDay: `${month}-${day}`,\n      hourMinuteSecond: `${hour}:${minute}:${second}`,\n      hourMinute: `${hour}:${minute}`,\n      dayOfWeek: this.date.getDay(),\n      dayOfWeekLong: this.date.toLocaleDateString(localeValue, {\n        weekday: \"long\"\n      }),\n      dayOfWeekShort: this.date.toLocaleDateString(localeValue, {\n        weekday: \"short\"\n      }),\n      longTime: this.date.getTime()\n    }\n  }\n\n  /**\n   * Validates whether a given Date object matches the specified year, month, day, hour, minute, and second.\n   *\n   * @param {Date} date - The Date object to validate.\n   * @param {number} year - The expected year.\n   * @param {number} month - The expected month (1-12).\n   * @param {number} [day] - The optional expected day of the month.\n   * @param {number} [hour] - The optional expected hour of the day (0-23).\n   * @param {number} [minute] - The optional expected minute (0-59).\n   * @param {number} [second] - The optional expected second (0-59).\n   * @returns {boolean} Returns `true` if all provided date components match the Date object, otherwise `false`.\n   */\n  private validationDate(\n    date: Date,\n    year: number,\n    month: number,\n    day?: number,\n    hour?: number,\n    minute?: number,\n    second?: number\n  ): boolean {\n    if (\n      date.getFullYear() !== year ||\n      date.getMonth() !== month - 1 ||\n      (day && date.getDate() !== day) ||\n      (hour && date.getHours() !== hour) ||\n      (minute && date.getMinutes() !== minute) ||\n      (second && date.getSeconds() !== second)\n    ) {\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Matches a date string in the format 'YYYY-MM-DD HH:MM:SS' and converts it to a Date object if valid.\n   *\n   * @param {number | string | Date} dateValue - A date string in 'YYYY-MM-DD HH:MM:SS' format or a Date object.\n   * @returns {Date | null} Returns the corresponding Date object if the date string is valid and matches the format, otherwise returns `null`.\n   * @throws {Error} Throws an error if the date string is invalid or does not match the expected format.\n   */\n  private matchDateValue(dateValue: number | string | Date): Date {\n    if (typeof dateValue !== \"string\") return null\n\n    // Date Format:\n    // YYYY-MM-DD HH:MM:SS\n    if (\n      /^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]) ([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/.test(\n        dateValue\n      )\n    ) {\n      const [datePart, timePart] = dateValue.split(\" \")\n      const [year, month, day] = datePart.split(\"-\").map(Number)\n      const [hour, minute, second] = timePart.split(\":\").map(Number)\n\n      const date = new Date(year, month - 1, day, hour, minute, second)\n\n      if (this.validationDate(date, year, month, day, hour, minute, second)) {\n        return date\n      } else {\n        throw new Error(\"Invalid date\")\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Parses a date value from a number, string, or Date object into a valid Date object.\n   *\n   * @param {number | string | Date} dateValue - The value to parse into a Date object. It can be a timestamp (number), a date string, or an existing Date object.\n   * @returns {Date} A valid Date object based on the provided input.\n   * @throws {Error} Throws an error if the number is not a valid finite timestamp.\n   * @throws {Error} Throws an error if the string cannot be parsed into a valid date.\n   * @throws {Error} Throws an error if the provided Date object is invalid (e.g., the time is NaN).\n   * @throws {Error} Throws an error if the input is not a number, string, or Date object.\n   */\n  private parse(dateValue: number | string | Date): Date {\n    if (typeof dateValue === \"number\") {\n      if (!isFinite(dateValue)) {\n        throw new Error(\"Invalid number provided for date\")\n      }\n      const date = new Date(dateValue)\n      if (isNaN(date.getTime())) {\n        throw new Error(\"Invalid date: number is not a valid timestamp\")\n      }\n      return date\n    }\n\n    if (typeof dateValue === \"string\") {\n      const matchedDate = this.matchDateValue(dateValue)\n      if (matchedDate) {\n        return matchedDate\n      }\n\n      const date = new Date(dateValue)\n      if (isNaN(date.getTime())) {\n        throw new Error(\"Invalid date string\")\n      }\n      return date\n    }\n\n    if (dateValue instanceof Date) {\n      if (isNaN(dateValue.getTime())) {\n        throw new Error(\"Invalid Date object provided\")\n      }\n      return dateValue\n    }\n\n    throw new Error(\"Invalid input: must be a number, string, or Date\")\n  }\n}\n\nexport default FuDate\n","import { MapFunction } from \"./interfaces\"\n\n/**\n * 제공된 매핑 함수를 사용하여 요소 배열을 비동기적으로 매핑하고 Promise를 반환합니다.\n *\n * @template T - 입력 배열의 요소 유형입니다.\n * @template U - 결과 배열의 요소 유형입니다.\n * @param {T[]} arr - 매핑할 요소의 배열.\n * @param {MapFunction<T, U>} MapFunction - T 유형의 요소를 가져와 U 유형의 값이나 U로 확인되는 Promise를 반환하는 매핑 함수입니다.\n * @returns {Promise<U[]>} 매핑 함수를 비동기적으로 적용한 후 반환된 배열의 Promise입니다.\n */\nfunction asyncMap<T, U>(\n  arr: T[],\n  MapFunction: MapFunction<T, U>\n): Promise<U[]> {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(\"Expected the first argument to be an array\")\n  }\n\n  if (typeof MapFunction !== \"function\") {\n    throw new TypeError(\"Expected the second argument to be a function\")\n  }\n\n  return Promise.all(arr.map(MapFunction))\n}\n\nexport { asyncMap }\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import { GroupedData } from \"./interfaces\"\n\n/**\n * 지정된 키를 기준으로 배열의 요소를 그룹화합니다.\n * 요소는 객체여야 하며, 키는 객체에 존재해야 합니다.\n *\n * @template T - 배열의 요소 유형은 객체로 제한됩니다.\n * @param {T[]} arr - 그룹화할 객체의 배열입니다.\n * @param {string} key - 배열 요소가 그룹화되는 키입니다. 이 키는 배열의 각 객체에 존재해야 합니다.\n * @returns {GroupedData<T>} 지정된 키의 값으로 그룹화된 객체입니다.\n */\nfunction groupBy<T extends object>(arr: T[], key: string): GroupedData<T> {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(\"Expected the first argument to be an array\")\n  }\n\n  if (arr.length > 0 && typeof arr[0] !== \"object\") {\n    throw new TypeError(\"Expected array elements to be objects\")\n  }\n\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"Expected the second argument to be a string\")\n  }\n\n  if (arr.length > 0 && !(key in arr[0])) {\n    throw new Error(`Key \"${key}\" does not exist in array elements`)\n  }\n\n  return arr.reduce((acc, item) => {\n    const group = item[key]\n    if (!acc[group]) {\n      acc[group] = []\n    }\n    acc[group].push(item)\n    return acc\n  }, {} as GroupedData<T>)\n}\n\nexport { groupBy }\n","import { groupBy } from \"array/groupBy\"\nimport { GroupedData } from \"./interfaces\"\n\n/**\n * 지정된 키를 기준으로 배열의 요소를 그룹화하고 사용자 정의한 정렬 함수를 사용하여 결과 그룹을 정렬합니다.\n *\n * @template T - 배열의 요소 유형은 객체로 제한됩니다.\n * @param {T[]} arr - 그룹화하고 정렬할 객체의 배열입니다.\n * @param {keyof T} key - 배열 요소가 그룹화되는 키입니다. 이 키는 배열의 각 객체에 존재해야 합니다.\n * @param {(a: T[keyof T], b: T[keyof T]) => number} comparator - 그룹을 어떻게 정렬해야 하는지 정의하는 비교 함수입니다.\n * @returns {Array<{ [K in keyof T]: T[K] } & { data: T[] }>} 지정된 키로 그룹화하고 정렬된 객체의 배열입니다.\n */\nfunction groupAndSort<T extends object>(\n  arr: T[],\n  key: keyof T,\n  comparator: (a: T[keyof T], b: T[keyof T]) => number\n): Array<{ [K in keyof T]: T[K] } & { data: T[] }> {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(\"Expected the first argument to be an array\")\n  }\n\n  if (arr.length > 0 && typeof arr[0] !== \"object\") {\n    throw new TypeError(\"Expected array elements to be objects\")\n  }\n\n  if (\n    typeof key !== \"string\" &&\n    typeof key !== \"symbol\" &&\n    typeof key !== \"number\"\n  ) {\n    throw new TypeError(\n      \"Expected the second argument to be a valid object key (string, symbol, or number)\"\n    )\n  }\n\n  if (arr.length > 0 && !(key in arr[0])) {\n    throw new Error(`Key \"${String(key)}\" does not exist in array elements`)\n  }\n\n  if (typeof comparator !== \"function\") {\n    throw new TypeError(\"Expected the third argument to be a function\")\n  }\n\n  const grouped: GroupedData<T> = groupBy(arr, key as string)\n  const result = Object.keys(grouped)\n    .map((groupKey) => ({\n      ...({ [key]: groupKey } as { [K in keyof T]: T[K] }),\n      data: grouped[groupKey]\n    }))\n    .sort((a, b) =>\n      comparator(\n        a[key] as unknown as T[keyof T],\n        b[key] as unknown as T[keyof T]\n      )\n    )\n\n  return result\n}\n\nexport { groupAndSort }\n","import { FilterFunction } from \"./interfaces\"\n\n/**\n * 여러 개의 필터 함수를 사용하여 배열을 필터링하고 필터링된 결과를 별도의 배열로 반환합니다.\n *\n * @template T - 배열 요소의 유형.\n * @param {T[]} arr - 필터링할 요소의 배열.\n * @param {Array<FilterFunction<T>>} filters - 필터 함수의 배열. 각 함수는 자체 기준에 따라 배열을 필터링합니다.\n * @returns {T[][]} 각 내부 배열에 해당 필터 함수로 필터링한 요소가 포함된 2차원 배열입니다.\n */\nfunction multiFilter<T>(arr: T[], filters: FilterFunction<T>[]): T[][] {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(\"Expected the first argument to be an array\")\n  }\n\n  if (!Array.isArray(filters)) {\n    throw new TypeError(\n      \"Expected the second argument to be an array of filter functions\"\n    )\n  }\n\n  if (!filters.every((fn) => typeof fn === \"function\")) {\n    throw new TypeError(\n      \"Expected every element in the filters array to be a function\"\n    )\n  }\n\n  if (arr.length === 0 || filters.length === 0) {\n    throw new TypeError(\"Expected a non-empty array.\")\n  }\n\n  const results = filters.map(() => [] as T[])\n  for (const item of arr) {\n    filters.forEach((filter, index) => {\n      if (filter(item)) {\n        results[index].push(item)\n      }\n    })\n  }\n  return results\n}\n\nexport { multiFilter }\n"],"names":["FuDate","dateValue","this","date","parse","Date","prototype","getDate","getDateProperties","locale","localeValue","Intl","DateTimeFormat","resolvedOptions","year","getFullYear","toString","month","getMonth","padStart","day","hour","getHours","minute","getMinutes","second","getSeconds","yearMonthDay","concat","yearMonth","monthDay","hourMinuteSecond","hourMinute","dayOfWeek","getDay","dayOfWeekLong","toLocaleDateString","weekday","dayOfWeekShort","longTime","getTime","validationDate","matchDateValue","test","_a","split","datePart","timePart","_b","map","Number","_c","Error","isFinite","isNaN","matchedDate","asyncMap","arr","MapFunction","Array","isArray","TypeError","Promise","all","__assign","Object","assign","t","s","i","n","arguments","length","p","hasOwnProperty","call","apply","groupBy","key","reduce","acc","item","group","push","groupAndSort","comparator","String","grouped","keys","groupKey","data","sort","a","b","multiFilter","filters","every","fn","results","forEach","filter","index","arr_1","_i","SuppressedError"],"mappings":"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","x_google_ignoreList":[2]}