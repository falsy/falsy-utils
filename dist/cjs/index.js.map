{"version":3,"file":"index.js","sources":["../../src/date/FuDate.ts","../../node_modules/tslib/tslib.es6.js","../../src/array/FuArray.ts"],"sourcesContent":["import { IDateProperties, IFuDate } from \"./IFuDate\"\n\nclass FuDate implements IFuDate {\n  private readonly date: Date\n\n  /**\n   * Initializes the class with a given date value or the current date if no value is provided.\n   *\n   * @param {number | string | Date} [dateValue] - The value used to initialize the date. It can be a timestamp (number), a date string, a Date object, or undefined.\n   * - If no value is provided, the current date and time will be used.\n   * - If a valid value is provided, it will be parsed into a Date object.\n   * @throws {Error} Throws an error if the provided date value cannot be parsed into a valid Date object.\n   *\n   * @example\n   * const instance1 = new FuDate(); // Initializes with the current date and time.\n   * const instance2 = new FuDate(1629918000000); // Initializes with a timestamp.\n   * const instance3 = new FuDate(\"2023-08-27T10:15:00Z\"); // Initializes with a valid date string.\n   * const instance4 = new FuDate(\"2023-08-27 10:15:00\"); // Initializes with a custom date string.\n   * const instance5 = new FuDate(new Date()); // Initializes with a Date object.\n   */\n  constructor(dateValue?: number | string | Date) {\n    if (typeof dateValue === \"undefined\") {\n      this.date = new Date()\n      return\n    }\n    this.date = this.parse(dateValue)\n  }\n\n  /**\n   * Retrieves the current date.\n   *\n   * @returns {Date} A Date object representing the current date and time.\n   */\n  getDate(): Date {\n    return this.date\n  }\n\n  /**\n   * Extracts various date and time properties from the Date object.\n   *\n   * @param {string} [locales] - Optional locale string for formatting the day of the week name. Defaults to the system's locale.\n   * @returns {IDateProperties} An object containing various date and time properties such as year, month, day, day of the week, and formatted strings.\n   */\n  getDateProperties(locales?: string): IDateProperties {\n    const localeValue = locales\n      ? locales\n      : Intl.DateTimeFormat().resolvedOptions().locale\n    const year = this.date.getFullYear().toString()\n    const month = (this.date.getMonth() + 1).toString().padStart(2, \"0\")\n    const day = this.date.getDate().toString().padStart(2, \"0\")\n    const hour = this.date.getHours().toString().padStart(2, \"0\")\n    const minute = this.date.getMinutes().toString().padStart(2, \"0\")\n    const second = this.date.getSeconds().toString().padStart(2, \"0\")\n\n    return {\n      year,\n      month,\n      day,\n      yearMonthDay: `${year}-${month}-${day}`,\n      yearMonth: `${year}-${month}`,\n      hourMinuteSecond: `${hour}:${minute}:${second}`,\n      hourMinute: `${hour}:${minute}`,\n      dayOfWeek: this.date.getDay(),\n      dayOfWeekLongName: this.date.toLocaleDateString(localeValue, {\n        weekday: \"long\"\n      }),\n      dayOfWeekShortName: this.date.toLocaleDateString(localeValue, {\n        weekday: \"short\"\n      }),\n      longTime: this.date.getTime()\n    }\n  }\n\n  /**\n   * Validates whether a given Date object matches the specified year, month, day, hour, minute, and second.\n   *\n   * @param {Date} date - The Date object to validate.\n   * @param {number} year - The expected year.\n   * @param {number} month - The expected month (1-12).\n   * @param {number} [day] - The optional expected day of the month.\n   * @param {number} [hour] - The optional expected hour of the day (0-23).\n   * @param {number} [minute] - The optional expected minute (0-59).\n   * @param {number} [second] - The optional expected second (0-59).\n   * @returns {boolean} Returns `true` if all provided date components match the Date object, otherwise `false`.\n   */\n  private validationDate(\n    date: Date,\n    year: number,\n    month: number,\n    day?: number,\n    hour?: number,\n    minute?: number,\n    second?: number\n  ): boolean {\n    if (\n      date.getFullYear() !== year ||\n      date.getMonth() !== month - 1 ||\n      (day && date.getDate() !== day) ||\n      (hour && date.getHours() !== hour) ||\n      (minute && date.getMinutes() !== minute) ||\n      (second && date.getSeconds() !== second)\n    ) {\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Matches a date string in the format 'YYYY-MM-DD HH:MM:SS' and converts it to a Date object if valid.\n   *\n   * @param {number | string | Date} dateValue - A date string in 'YYYY-MM-DD HH:MM:SS' format or a Date object.\n   * @returns {Date | null} Returns the corresponding Date object if the date string is valid and matches the format, otherwise returns `null`.\n   * @throws {Error} Throws an error if the date string is invalid or does not match the expected format.\n   */\n  private matchDateValue(dateValue: number | string | Date): Date {\n    if (typeof dateValue !== \"string\") return null\n\n    // Date Format:\n    // YYYY-MM-DD HH:MM:SS\n    if (\n      /^\\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]) ([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/.test(\n        dateValue\n      )\n    ) {\n      const [datePart, timePart] = dateValue.split(\" \")\n      const [year, month, day] = datePart.split(\"-\").map(Number)\n      const [hour, minute, second] = timePart.split(\":\").map(Number)\n\n      const date = new Date(year, month - 1, day, hour, minute, second)\n\n      if (this.validationDate(date, year, month, day, hour, minute, second)) {\n        return date\n      } else {\n        throw new Error(\"Invalid date\")\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Parses a date value from a number, string, or Date object into a valid Date object.\n   *\n   * @param {number | string | Date} dateValue - The value to parse into a Date object. It can be a timestamp (number), a date string, or an existing Date object.\n   * @returns {Date} A valid Date object based on the provided input.\n   * @throws {Error} Throws an error if the number is not a valid finite timestamp.\n   * @throws {Error} Throws an error if the string cannot be parsed into a valid date.\n   * @throws {Error} Throws an error if the provided Date object is invalid (e.g., the time is NaN).\n   * @throws {Error} Throws an error if the input is not a number, string, or Date object.\n   *\n   * @example\n   * // Parsing a timestamp\n   * const date1 = parse(1629918000000); // Valid timestamp\n   *\n   * // Parsing a valid date string\n   * const date2 = parse(\"2023-08-27T10:15:00Z\"); // Valid date string\n   *\n   * // Parsing an existing Date object\n   * const date3 = parse(new Date()); // Valid Date object\n   *\n   * // Throws an error for invalid input\n   * parse(\"invalid-date\"); // Throws: \"Invalid date string\"\n   */\n  private parse(dateValue: number | string | Date): Date {\n    if (typeof dateValue === \"number\") {\n      if (!isFinite(dateValue)) {\n        throw new Error(\"Invalid number provided for date\")\n      }\n      const date = new Date(dateValue)\n      if (isNaN(date.getTime())) {\n        throw new Error(\"Invalid date: number is not a valid timestamp\")\n      }\n      return date\n    }\n\n    if (typeof dateValue === \"string\") {\n      const matchedDate = this.matchDateValue(dateValue)\n      if (matchedDate) {\n        return matchedDate\n      }\n\n      const date = new Date(dateValue)\n      if (isNaN(date.getTime())) {\n        throw new Error(\"Invalid date string\")\n      }\n      return date\n    }\n\n    if (dateValue instanceof Date) {\n      if (isNaN(dateValue.getTime())) {\n        throw new Error(\"Invalid Date object provided\")\n      }\n      return dateValue\n    }\n\n    throw new Error(\"Invalid input: must be a number, string, or Date\")\n  }\n}\n\nexport default FuDate\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import { FilterFunction, GroupedData } from \"./IFuArray\"\n\n/**\n * Groups the elements of an array based on the specified key.\n * The elements must be objects, and the key must exist in the objects.\n *\n * @template T - The type of elements in the array, constrained to objects.\n * @param {T[]} arr - The array of objects to be grouped.\n * @param {string} key - The key by which the array elements will be grouped. This key must exist in each object in the array.\n * @returns {GroupedData<T>} An object where the keys are the unique values of the specified key in the array, and the values are arrays of objects that share that key.\n * @throws {TypeError} Throws an error if the first argument is not an array.\n * @throws {TypeError} Throws an error if the elements of the array are not objects.\n * @throws {TypeError} Throws an error if the second argument is not a string.\n * @throws {Error} Throws an error if the specified key does not exist in the elements of the array.\n *\n * @example\n * const arr = [\n *   { name: 'Alice', age: 25 },\n *   { name: 'Bob', age: 30 },\n *   { name: 'Charlie', age: 25 }\n * ];\n * const result = groupBy(arr, 'age');\n * // result will be:\n * // {\n * //   \"25\": [\n * //     { name: 'Alice', age: 25 },\n * //     { name: 'Charlie', age: 25 }\n * //   ],\n * //   \"30\": [\n * //     { name: 'Bob', age: 30 }\n * //   ]\n * // }\n */\nfunction groupBy<T extends object>(arr: T[], key: string): GroupedData<T> {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(\"Expected the first argument to be an array\")\n  }\n\n  if (arr.length > 0 && typeof arr[0] !== \"object\") {\n    throw new TypeError(\"Expected array elements to be objects\")\n  }\n\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"Expected the second argument to be a string\")\n  }\n\n  if (arr.length > 0 && !(key in arr[0])) {\n    throw new Error(`Key \"${key}\" does not exist in array elements`)\n  }\n\n  return arr.reduce((acc, item) => {\n    const group = item[key]\n    if (!acc[group]) {\n      acc[group] = []\n    }\n    acc[group].push(item)\n    return acc\n  }, {} as GroupedData<T>)\n}\n\n/**\n * Groups the elements of an array based on the specified key and sorts the resulting groups using a custom comparator.\n *\n * @template T - The type of elements in the array, constrained to objects.\n * @param {T[]} arr - The array of objects to be grouped and sorted.\n * @param {keyof T} key - The key by which the array elements will be grouped. This key must exist in the objects inside the array.\n * @param {(a: T[keyof T], b: T[keyof T]) => number} comparator - A comparator function that defines how the groups should be sorted. It takes two values of the specified key and returns a negative number, zero, or a positive number to determine the sort order.\n * @returns {Array<{ [K in keyof T]: T[K] } & { data: T[] }>} An array of objects where each object represents a group. Each group contains the key (with the grouped value) and a `data` array containing the grouped elements.\n * @throws {TypeError} Throws an error if the first argument is not an array.\n * @throws {TypeError} Throws an error if the elements of the array are not objects.\n * @throws {TypeError} Throws an error if the second argument is not a valid object key (string, symbol, or number).\n * @throws {Error} Throws an error if the specified key does not exist in the elements of the array.\n * @throws {TypeError} Throws an error if the third argument is not a function.\n *\n * @example\n * const arr = [\n *   { name: 'Alice', age: 25 },\n *   { name: 'Bob', age: 30 },\n *   { name: 'Charlie', age: 25 }\n * ];\n * const result = groupAndSort(arr, 'age', (a, b) => (a as number) - (b as number));\n * // result will be:\n * // [\n * //   { age: 25, data: [ { name: 'Alice', age: 25 }, { name: 'Charlie', age: 25 } ] },\n * //   { age: 30, data: [ { name: 'Bob', age: 30 } ] }\n * // ]\n */\nfunction groupAndSort<T extends object>(\n  arr: T[],\n  key: keyof T,\n  comparator: (a: T[keyof T], b: T[keyof T]) => number\n): Array<{ [K in keyof T]: T[K] } & { data: T[] }> {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(\"Expected the first argument to be an array\")\n  }\n\n  if (arr.length > 0 && typeof arr[0] !== \"object\") {\n    throw new TypeError(\"Expected array elements to be objects\")\n  }\n\n  if (\n    typeof key !== \"string\" &&\n    typeof key !== \"symbol\" &&\n    typeof key !== \"number\"\n  ) {\n    throw new TypeError(\n      \"Expected the second argument to be a valid object key (string, symbol, or number)\"\n    )\n  }\n\n  if (arr.length > 0 && !(key in arr[0])) {\n    throw new Error(`Key \"${String(key)}\" does not exist in array elements`)\n  }\n\n  if (typeof comparator !== \"function\") {\n    throw new TypeError(\"Expected the third argument to be a function\")\n  }\n\n  const grouped: GroupedData<T> = groupBy(arr, key as string)\n  const result = Object.keys(grouped)\n    .map((groupKey) => ({\n      ...({ [key]: groupKey } as { [K in keyof T]: T[K] }),\n      data: grouped[groupKey]\n    }))\n    .sort((a, b) =>\n      comparator(\n        a[key] as unknown as T[keyof T],\n        b[key] as unknown as T[keyof T]\n      )\n    )\n\n  return result\n}\n\n/**\n * Filters an array using multiple filter functions and returns the filtered results in separate arrays.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} arr - The array of elements to be filtered.\n * @param {Array<FilterFunction<T>>} filters - An array of filter functions. Each function filters the array by its own criteria.\n * @returns {T[][]} A two-dimensional array where each inner array contains the elements filtered by the corresponding filter function.\n * @throws {TypeError} Throws an error if the first argument is not an array.\n * @throws {TypeError} Throws an error if the second argument is not an array of functions.\n * @throws {TypeError} Throws an error if any element in the filters array is not a function.\n *\n * @example\n * const arr = [1, 2, 3, 4, 5, 6];\n * const filters = [\n *   (n) => n % 2 === 0,  // Filter even numbers\n *   (n) => n % 2 !== 0   // Filter odd numbers\n * ];\n * const result = multiFilter(arr, filters);\n * // result will be [[2, 4, 6], [1, 3, 5]]\n */\nfunction multiFilter<T>(arr: T[], filters: FilterFunction<T>[]): T[][] {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(\"Expected the first argument to be an array\")\n  }\n\n  if (!Array.isArray(filters)) {\n    throw new TypeError(\n      \"Expected the second argument to be an array of filter functions\"\n    )\n  }\n\n  if (!filters.every((fn) => typeof fn === \"function\")) {\n    throw new TypeError(\n      \"Expected every element in the filters array to be a function\"\n    )\n  }\n\n  if (filters.length === 0 || arr.length === 0) {\n    return []\n  }\n\n  const results = filters.map(() => [] as T[])\n  for (const item of arr) {\n    filters.forEach((filter, index) => {\n      if (filter(item)) {\n        results[index].push(item)\n      }\n    })\n  }\n  return results\n}\n\nexport { multiFilter, groupBy, groupAndSort }\n"],"names":["FuDate","dateValue","this","date","parse","Date","prototype","getDate","getDateProperties","locales","localeValue","Intl","DateTimeFormat","resolvedOptions","locale","year","getFullYear","toString","month","getMonth","padStart","day","hour","getHours","minute","getMinutes","second","getSeconds","yearMonthDay","concat","yearMonth","hourMinuteSecond","hourMinute","dayOfWeek","getDay","dayOfWeekLongName","toLocaleDateString","weekday","dayOfWeekShortName","longTime","getTime","validationDate","matchDateValue","test","_a","split","datePart","timePart","_b","map","Number","_c","Error","isFinite","isNaN","matchedDate","__assign","Object","assign","t","s","i","n","arguments","length","p","hasOwnProperty","call","apply","groupBy","arr","key","Array","isArray","TypeError","reduce","acc","item","group","push","SuppressedError","comparator","String","grouped","keys","groupKey","data","sort","a","b","filters","every","fn","results","forEach","filter","index","arr_1","_i"],"mappings":"aAEA,IAAAA,EAAA,WAkBE,SAAAA,EAAYC,GAKVC,KAAKC,UAJoB,IAAdF,EAICC,KAAKE,MAAMH,GAHT,IAAII,IAInB,CA2KH,OApKEL,EAAAM,UAAAC,QAAA,WACE,OAAOL,KAAKC,MASdH,EAAiBM,UAAAE,kBAAjB,SAAkBC,GAChB,IAAMC,EAAcD,GAEhBE,KAAKC,iBAAiBC,kBAAkBC,OACtCC,EAAOb,KAAKC,KAAKa,cAAcC,WAC/BC,GAAShB,KAAKC,KAAKgB,WAAa,GAAGF,WAAWG,SAAS,EAAG,KAC1DC,EAAMnB,KAAKC,KAAKI,UAAUU,WAAWG,SAAS,EAAG,KACjDE,EAAOpB,KAAKC,KAAKoB,WAAWN,WAAWG,SAAS,EAAG,KACnDI,EAAStB,KAAKC,KAAKsB,aAAaR,WAAWG,SAAS,EAAG,KACvDM,EAASxB,KAAKC,KAAKwB,aAAaV,WAAWG,SAAS,EAAG,KAE7D,MAAO,CACLL,KAAIA,EACJG,MAAKA,EACLG,IAAGA,EACHO,aAAc,GAAGC,OAAAd,cAAQG,EAAK,KAAAW,OAAIR,GAClCS,UAAW,GAAAD,OAAGd,EAAI,KAAAc,OAAIX,GACtBa,iBAAkB,GAAGF,OAAAP,cAAQE,EAAM,KAAAK,OAAIH,GACvCM,WAAY,GAAAH,OAAGP,EAAI,KAAAO,OAAIL,GACvBS,UAAW/B,KAAKC,KAAK+B,SACrBC,kBAAmBjC,KAAKC,KAAKiC,mBAAmB1B,EAAa,CAC3D2B,QAAS,SAEXC,mBAAoBpC,KAAKC,KAAKiC,mBAAmB1B,EAAa,CAC5D2B,QAAS,UAEXE,SAAUrC,KAAKC,KAAKqC,YAgBhBxC,EAAAM,UAAAmC,eAAR,SACEtC,EACAY,EACAG,EACAG,EACAC,EACAE,EACAE,GAEA,QACEvB,EAAKa,gBAAkBD,GACvBZ,EAAKgB,aAAeD,EAAQ,GAC3BG,GAAOlB,EAAKI,YAAcc,GAC1BC,GAAQnB,EAAKoB,aAAeD,GAC5BE,GAAUrB,EAAKsB,eAAiBD,GAChCE,GAAUvB,EAAKwB,eAAiBD,IAc7B1B,EAAcM,UAAAoC,eAAtB,SAAuBzC,GACrB,GAAyB,iBAAdA,EAAwB,OAAO,KAI1C,GACE,iGAAiG0C,KAC/F1C,GAEF,CACM,IAAA2C,EAAuB3C,EAAU4C,MAAM,KAAtCC,EAAQF,EAAA,GAAEG,OACXC,EAAqBF,EAASD,MAAM,KAAKI,IAAIC,QAA5CnC,EAAIiC,EAAA,GAAE9B,EAAK8B,EAAA,GAAE3B,EAAG2B,EAAA,GACjBG,EAAyBJ,EAASF,MAAM,KAAKI,IAAIC,QAAhD5B,EAAI6B,EAAA,GAAE3B,EAAM2B,EAAA,GAAEzB,EAAMyB,EAAA,GAErBhD,EAAO,IAAIE,KAAKU,EAAMG,EAAQ,EAAGG,EAAKC,EAAME,EAAQE,GAE1D,GAAIxB,KAAKuC,eAAetC,EAAMY,EAAMG,EAAOG,EAAKC,EAAME,EAAQE,GAC5D,OAAOvB,EAEP,MAAM,IAAIiD,MAAM,eAEnB,CAED,OAAO,MA0BDpD,EAAKM,UAAAF,MAAb,SAAcH,GACZ,GAAyB,iBAAdA,EAAwB,CACjC,IAAKoD,SAASpD,GACZ,MAAM,IAAImD,MAAM,oCAElB,IAAMjD,EAAO,IAAIE,KAAKJ,GACtB,GAAIqD,MAAMnD,EAAKqC,WACb,MAAM,IAAIY,MAAM,iDAElB,OAAOjD,CACR,CAED,GAAyB,iBAAdF,EAAwB,CACjC,IAAMsD,EAAcrD,KAAKwC,eAAezC,GACxC,GAAIsD,EACF,OAAOA,EAGHpD,EAAO,IAAIE,KAAKJ,GACtB,GAAIqD,MAAMnD,EAAKqC,WACb,MAAM,IAAIY,MAAM,uBAElB,OAAOjD,CACR,CAED,GAAIF,aAAqBI,KAAM,CAC7B,GAAIiD,MAAMrD,EAAUuC,WAClB,MAAM,IAAIY,MAAM,gCAElB,OAAOnD,CACR,CAED,MAAM,IAAImD,MAAM,qDAEnBpD,CAAD,ICtKWwD,EAAW,WAQlB,OAPAA,EAAWC,OAAOC,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAII,KADTL,EAAIG,UAAUF,GACOJ,OAAOnD,UAAU4D,eAAeC,KAAKP,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,IAE9E,OAAON,CACV,EACMH,EAASY,MAAMlE,KAAM6D,UAChC,ECPA,SAASM,EAA0BC,EAAUC,GAC3C,IAAKC,MAAMC,QAAQH,GACjB,MAAM,IAAII,UAAU,8CAGtB,GAAIJ,EAAIN,OAAS,GAAuB,iBAAXM,EAAI,GAC/B,MAAM,IAAII,UAAU,yCAGtB,GAAmB,iBAARH,EACT,MAAM,IAAIG,UAAU,+CAGtB,GAAIJ,EAAIN,OAAS,KAAOO,KAAOD,EAAI,IACjC,MAAM,IAAIlB,MAAM,eAAQmB,EAAG,uCAG7B,OAAOD,EAAIK,QAAO,SAACC,EAAKC,GACtB,IAAMC,EAAQD,EAAKN,GAKnB,OAJKK,EAAIE,KACPF,EAAIE,GAAS,IAEfF,EAAIE,GAAOC,KAAKF,GACTD,CACR,GAAE,CAAoB,EACzB,CDqQkD,mBAApBI,iBAAiCA,sDCxO/D,SACEV,EACAC,EACAU,GAEA,IAAKT,MAAMC,QAAQH,GACjB,MAAM,IAAII,UAAU,8CAGtB,GAAIJ,EAAIN,OAAS,GAAuB,iBAAXM,EAAI,GAC/B,MAAM,IAAII,UAAU,yCAGtB,GACiB,iBAARH,GACQ,iBAARA,GACQ,iBAARA,EAEP,MAAM,IAAIG,UACR,qFAIJ,GAAIJ,EAAIN,OAAS,KAAOO,KAAOD,EAAI,IACjC,MAAM,IAAIlB,MAAM,QAAQvB,OAAAqD,OAAOX,GAAwC,uCAGzE,GAA0B,mBAAfU,EACT,MAAM,IAAIP,UAAU,gDAGtB,IAAMS,EAA0Bd,EAAQC,EAAKC,GAa7C,OAZed,OAAO2B,KAAKD,GACxBlC,KAAI,SAACoC,SAAa,gBACbzC,EAAA,CAAA,GAAG2B,GAAMc,EAAQzC,IAA+B,CACpD0C,KAAMH,EAAQE,IAFG,IAIlBE,MAAK,SAACC,EAAGC,GACR,OAAAR,EACEO,EAAEjB,GACFkB,EAAElB,GAFJ,GAON,wCAsBA,SAAwBD,EAAUoB,GAChC,IAAKlB,MAAMC,QAAQH,GACjB,MAAM,IAAII,UAAU,8CAGtB,IAAKF,MAAMC,QAAQiB,GACjB,MAAM,IAAIhB,UACR,mEAIJ,IAAKgB,EAAQC,OAAM,SAACC,GAAO,MAAc,mBAAPA,KAChC,MAAM,IAAIlB,UACR,gEAIJ,GAAuB,IAAnBgB,EAAQ1B,QAA+B,IAAfM,EAAIN,OAC9B,MAAO,GAIT,IADA,IAAM6B,EAAUH,EAAQzC,KAAI,WAAM,MAAA,EAAS,eAChC4B,GACTa,EAAQI,SAAQ,SAACC,EAAQC,GACnBD,EAAOlB,IACTgB,EAAQG,GAAOjB,KAAKF,EAExB,SALiBoB,EAAA3B,EAAA4B,EAAAD,EAAAjC,OAAAkC,IAAG,GAAPD,EAAAC,GAMd,CACD,OAAOL,CACT","x_google_ignoreList":[1]}